# Concurrency Issue

## 동시성 문제란 무엇인가?

동시성 문제란 여러 개의 프로세스 혹은 스레드가 공유 자원에 접근하거나 조작할 때 발생하는 의도치 않은 문제를 말함. 여기서 말하는 의도치 않은 문제란 예를 하나의 좌석을 두고 서로 다른 유저가 동시에 예약을 했는데 두 명 다 예약이 되는 상황을 의미. 이러한 문제는 경쟁 상태(Race Condition), 데이터 불일치 등으로 발생하며 임계 구역(Critical Section)을 적절히 보호하지 않을 때 발생함.

---
## 동시성 문제가 발생했을 때 해결방법은?

동시성 문제를 해결하는 데는 다양한 전략이 있음.

### Lock / Mutex / Synchronized
락이나 뮤텍스를 사용함으로써 상호 배제(Mutual Exclusion)을 적용하여 한 번에 스레드만 해당 코드를 실행토록 함. 예를 들어, 자바에세는 `synchronized` 키워드를 사용하여 메서드나 블록에 락을 걸어 스레드가 자원을 점유 중일 때 다른 스레드가 자원에 접근하는 걸 막음. 이를 통해 하나의 스레드 자원 접근을 보장할 수 있지만 락 사용이 많아지면 데드락 위험 및 성능 저하가 일어날 수 있음. 

(Java에서 Mutex는 `lock`이나 `synchronized`로 구현됨)

### Semaphore
락과 유사하지만 지정된 카운트까지 허용하는 동기화하는 도구. Lock과 다른 점은 공유 자원에 접근할 수 있는 스레드를 조절할 수 있음. 

### Atomic operation
하드웨어나 언어 레벨에서 제공하는 원자성(Atomic)을 가지는 연산을 활용하여 동시성 문제를 해결. Java 관련해서는  `AtomicInteger`, `incrementAndGet()` 등이 있음.


## DB 트랜잭션과 락의 관계
DB 역시 하나의 자원이므로 DB 자원을 두고 동시성 문제가 발생할 수 있음. 여기서 트랜잭션은 여러 개의 연산을 원자성(Atomic) 있게 만들어주는 작업임. 즉 DB에 어떤 정보를 Write 할 경우, 비즈니스 로직에서는 먼저 데이터를 읽고 변경할 수 있는 시나리오가 있는데 이 여러 개의 로직들을 하나의 논리적인 단위로 묶은 게 트랜잭션임. 그렇기에 트랜잭션은 원자성을 띔. 모두 성공하거나, 아니면 모두 실패하거나... 

그러나 트랜잭션은 일련의 데이터베이스 연산을 묶어 ACID(Atomicity + Consistency + Isolation + Durability)만 보장할 뿐 동시성 문제를 해결할 수 없음. 

**여기서 잠깐 ACID에 대해서...**
* 원자성(Atomicity): 트랜잭션 내의 모든 연산을 하나의 논리적인 집합으로 묶음. 그렇기에 데이터의 일관성 유지. 모두 성공하거나, 모두 실패하거나
* 일관성(Consistency): 트랜잭션이 시작된 이전과 이후 모두 데이터베이스의 상태는 정의된 규칙(제약 조건, 데이터 무결성 등)을 항상 만족해야 함.
* 격리성(Isolation): 동시에 실행되는 트랜잭션은 서로에 셩향을 주지 않고 독립적으로 실행되는 것처럼 보여야 함. 하지만 트랜잭션도 격리 수준을 설정할 수도 있어 이 부분은 조금 애매함.
* 지속성(Durability): 완료된 트랜잭션 결과는 영구적으로 데이터베이스에 반영돼야 함. 시스템 장애 시에도 손실되면 안 됨

그런데 한 가지 의문이 든다. Java에서 `AtomicInteger`같은 타입을 사용하면 동시성 문제에 대응이 가능하다. 그런데 트랜잭션 역시 여러 연산을 논리적으로 원자성을 보장해주는데 왜 트랜잭션만으로는 동시성 문제에 대한 해결이 안 되는 걸까?
-> 이는 적용 범위가 다르기 때문이다. `AtomicInteger` 의 경우에는 적용 범위가 메모리에 있는 int 단일 변수 하나인 반면, 트랜잭션은 여러 개의 연산을 묶어 ACID를 보장하기에 조금 더 커버하는 범위가 넓다.

다시, 원래 논의로 돌아가서 트랜잭션은 여러 연산의 논리적 원자성을 보장하지만 여러 트랜잭션이 동시에 공유 자원에 접근하면 데이터 불일치 문제가 발생할 수 있다. 그렇기에 트랜잭션 동시성 문제를 해소하기 위해서는 여러가지 방법이 있다.
* Redis 등을 활용한 Lock
	* 문자 그대로 Redis 같은 메모리 락(?)을 활용해 락 통제권을 넘기는 것이다. 중앙 통제자가 반드시 Redis일 필요는 없다. 스프링 애플리케이션 자체 메모리 락도 가능하다. 다만 이렇게 할 경우, 세션에서 발생하는 문제 같은 인스턴스가 여러 개로 늘어날 시 대응이 제한된다.
* DB 락: DB를 활용한 락이다. 그 중에서도 낙관적 락과 비관적 락이 있으며 낙관적 락은 DB 컬럼을 활용한 락이지만 애플리케이션 레벨에서 걸리는 락이며, 비관적 락은 DB 자체적으로 지원하는 락이다.
	* 낙관적 락(Optimistic Lock): 낙관적 락은 테이블에 `Version`이라는 필드를 하나 두고 트랜잭션이 해당 테이블에 접근하고 사용이 끝나면 해당 버전 컬럼 값을 증가시킨다. 이때 두 개의 트랜잭션이 동시에 접근했을 때 트랜잭션 시작과 종료 시 버전 값이 상이하면 예외를 발생시킨다. 이때 예외 발생 후에 어떻게 대응 로직을 작성할지는 개발자에게 달렸다. 즉 DB가 아닌 애플리케이션 단에서 대응 로직을 작성해야 한다. 
		* `Version` 필드로 충돌을 감지하고, 충돌이 감지되면 이후 대응 로직을 실행하는 만큼 낙관적 락은 데이터 충돌이 드물다는 가정이 깔려 있다. 트랜잭션에서 `Version`이 변경되면  `OptimisticLockException` 발생
	* 비관적 락(Pessimistic Lock): DB 자체에서 제공하는 락이다. 즉, 비관적 락은 트랜잭션이 특정 자원을 점유 중일 때 다른 트랜잭션의 접근을 DB가 원천적으로 막는다. 그렇기에 그 다음 트랜잭션은 락 획득 시까지 대기해야 한다. DB 자체 내에서 락을 제공하기에 데이터의 무결성 및 일관성을 보장할 수 있다는 장점이 있지만 강력한 만큼 여러 트랜잭션의 접근이 빈번할 경우 성능 저하가 발생할 수 있다.
		* 비관적 락은 SQL의 `SELECT ... FOR UPDATE` 같은 구문을 활용해 구현됨
		* 사실 위의 비관적 락 설명은 잘못된 부분이 있다. 비관락은 세분화해서 이해해야 하기 때문이다. 비관적 락은 배타적 락(Exclusive Lock)과 공유 락(Shared Lock)으로 나뉜다.
		* 배타적 락(Exclusive Lock): 배타적 락은 특정 자원(행이나 테이블 등)에 독점적인 쓰기 권한을 부여한다. 즉, 다른 트랜잭션은 락이 해제될 때까지 **읽기와 쓰기가 모두 불가하다.**  (위의 비관적 락 정의에 쓴 락이 배타적 락이다)
		* 공유 락(Shared Lock): 공유 자원에 대해 읽기 권한은 여러 트랜잭션이 공유를 허용하는 락. 그러나 쓰기 작업은 안 됨. 즉 여러 트랜잭션이 특정 테이블이나 행을 동시에 읽는 건 가능하지만 쓰기 작업은 공유 락이 해제될 때까지 허용 X
	* **대응 관계**: 낙관적 락 ↔ 비관적 락 (전략적 대립), 비관적 락 ⊃ {배타적 락, 공유 락} (구현 방식).